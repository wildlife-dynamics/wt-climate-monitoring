# AUTOGENERATED BY ECOSCOPE-WORKFLOWS; see fingerprint in README.md for details
import json
import os

from ecoscope_workflows_core.graph import DependsOn, Graph, Node
from ecoscope_workflows_core.tasks.config import (
    set_workflow_details as set_workflow_details,
)
from ecoscope_workflows_core.tasks.filter import (
    get_timezone_from_time_range as get_timezone_from_time_range,
)
from ecoscope_workflows_core.tasks.filter import set_time_range as set_time_range
from ecoscope_workflows_core.tasks.groupby import set_groupers as set_groupers
from ecoscope_workflows_core.tasks.groupby import split_groups as split_groups
from ecoscope_workflows_core.tasks.io import persist_text as persist_text
from ecoscope_workflows_core.tasks.io import set_er_connection as set_er_connection
from ecoscope_workflows_core.tasks.results import (
    create_plot_widget_single_view as create_plot_widget_single_view,
)
from ecoscope_workflows_core.tasks.results import gather_dashboard as gather_dashboard
from ecoscope_workflows_core.tasks.results import (
    merge_widget_views as merge_widget_views,
)
from ecoscope_workflows_core.tasks.transformation import (
    add_temporal_index as add_temporal_index,
)
from ecoscope_workflows_core.tasks.transformation import (
    convert_values_to_timezone as convert_values_to_timezone,
)
from ecoscope_workflows_core.tasks.transformation import (
    extract_column_as_type as extract_column_as_type,
)
from ecoscope_workflows_core.tasks.transformation import map_columns as map_columns
from ecoscope_workflows_ext_custom.tasks.io import (
    persist_df_wrapper as persist_df_wrapper,
)
from ecoscope_workflows_ext_custom.tasks.transformation import (
    drop_column_prefix as drop_column_prefix,
)
from ecoscope_workflows_ext_custom.tasks.transformation import (
    filter_row_values as filter_row_values,
)
from ecoscope_workflows_ext_ecoscope.tasks.analysis import summarize_df as summarize_df
from ecoscope_workflows_ext_ecoscope.tasks.io import (
    get_subjectgroup_observations as get_subjectgroup_observations,
)
from ecoscope_workflows_ext_ecoscope.tasks.results import (
    draw_line_chart as draw_line_chart,
)
from ecoscope_workflows_ext_ecoscope.tasks.transformation import (
    normalize_json_column as normalize_json_column,
)

from ..params import Params


def main(params: Params):
    params_dict = json.loads(params.model_dump_json(exclude_unset=True))

    dependencies = {
        "workflow_details": [],
        "time_range": [],
        "get_timezone": ["time_range"],
        "er_client_name": [],
        "subject_obs": ["er_client_name", "time_range"],
        "drop_extra_prefix": ["subject_obs"],
        "process_columns": ["drop_extra_prefix"],
        "convert_to_user_timezone": ["process_columns", "get_timezone"],
        "normalize_obs_details": ["convert_to_user_timezone"],
        "drop_obs_details_prefix": ["normalize_obs_details"],
        "extract_date": ["drop_obs_details_prefix"],
        "filtered_weather_station": ["extract_date"],
        "groupers": [],
        "df_with_temporal_index": ["filtered_weather_station", "groupers"],
        "split_weather_groups": ["df_with_temporal_index", "groupers"],
        "persist_observations": ["split_weather_groups"],
        "daily_weather": ["split_weather_groups"],
        "persist_daily_summary": ["daily_weather"],
        "precipitation_chart": ["daily_weather"],
        "persist_precipitation": ["precipitation_chart"],
        "precipitation_chart_widget": ["persist_precipitation"],
        "grouped_precipitation_widget": ["precipitation_chart_widget"],
        "temperature_chart": ["daily_weather"],
        "persist_temperature": ["temperature_chart"],
        "temperature_chart_widget": ["persist_temperature"],
        "grouped_temperature_widget": ["temperature_chart_widget"],
        "weather_dashboard": [
            "workflow_details",
            "grouped_precipitation_widget",
            "grouped_temperature_widget",
            "time_range",
            "groupers",
        ],
    }

    nodes = {
        "workflow_details": Node(
            async_task=set_workflow_details.validate()
            .set_task_instance_id("workflow_details")
            .handle_errors()
            .with_tracing()
            .set_executor("lithops"),
            partial=(params_dict.get("workflow_details") or {}),
            method="call",
        ),
        "time_range": Node(
            async_task=set_time_range.validate()
            .set_task_instance_id("time_range")
            .handle_errors()
            .with_tracing()
            .set_executor("lithops"),
            partial={
                "time_format": "%d %b %Y %H:%M:%S %Z",
            }
            | (params_dict.get("time_range") or {}),
            method="call",
        ),
        "get_timezone": Node(
            async_task=get_timezone_from_time_range.validate()
            .set_task_instance_id("get_timezone")
            .handle_errors()
            .with_tracing()
            .set_executor("lithops"),
            partial={
                "time_range": DependsOn("time_range"),
            }
            | (params_dict.get("get_timezone") or {}),
            method="call",
        ),
        "er_client_name": Node(
            async_task=set_er_connection.validate()
            .set_task_instance_id("er_client_name")
            .handle_errors()
            .with_tracing()
            .set_executor("lithops"),
            partial=(params_dict.get("er_client_name") or {}),
            method="call",
        ),
        "subject_obs": Node(
            async_task=get_subjectgroup_observations.validate()
            .set_task_instance_id("subject_obs")
            .handle_errors()
            .with_tracing()
            .set_executor("lithops"),
            partial={
                "client": DependsOn("er_client_name"),
                "time_range": DependsOn("time_range"),
                "raise_on_empty": True,
                "include_details": True,
                "include_subjectsource_details": True,
                "subject_group_name": "Subjects",
            }
            | (params_dict.get("subject_obs") or {}),
            method="call",
        ),
        "drop_extra_prefix": Node(
            async_task=drop_column_prefix.validate()
            .set_task_instance_id("drop_extra_prefix")
            .handle_errors()
            .with_tracing()
            .set_executor("lithops"),
            partial={
                "df": DependsOn("subject_obs"),
                "prefix": "extra__",
                "duplicate_strategy": "suffix",
            }
            | (params_dict.get("drop_extra_prefix") or {}),
            method="call",
        ),
        "process_columns": Node(
            async_task=map_columns.validate()
            .set_task_instance_id("process_columns")
            .handle_errors()
            .with_tracing()
            .set_executor("lithops"),
            partial={
                "df": DependsOn("drop_extra_prefix"),
                "retain_columns": [
                    "id",
                    "subject_id",
                    "created_at",
                    "recorded_at",
                    "source",
                    "device_status_properties",
                    "observation_details",
                    "geometry",
                    "subject__name",
                ],
                "rename_columns": {
                    "subject__name": "weather_station",
                },
            }
            | (params_dict.get("process_columns") or {}),
            method="call",
        ),
        "convert_to_user_timezone": Node(
            async_task=convert_values_to_timezone.validate()
            .set_task_instance_id("convert_to_user_timezone")
            .handle_errors()
            .with_tracing()
            .set_executor("lithops"),
            partial={
                "df": DependsOn("process_columns"),
                "timezone": DependsOn("get_timezone"),
                "columns": [
                    "time",
                ],
            }
            | (params_dict.get("convert_to_user_timezone") or {}),
            method="call",
        ),
        "normalize_obs_details": Node(
            async_task=normalize_json_column.validate()
            .set_task_instance_id("normalize_obs_details")
            .handle_errors()
            .with_tracing()
            .set_executor("lithops"),
            partial={
                "df": DependsOn("convert_to_user_timezone"),
                "column": "observation_details",
                "skip_if_not_exists": False,
                "sort_columns": True,
            }
            | (params_dict.get("normalize_obs_details") or {}),
            method="call",
        ),
        "drop_obs_details_prefix": Node(
            async_task=drop_column_prefix.validate()
            .set_task_instance_id("drop_obs_details_prefix")
            .handle_errors()
            .with_tracing()
            .set_executor("lithops"),
            partial={
                "df": DependsOn("normalize_obs_details"),
                "prefix": "observation_details__",
                "duplicate_strategy": "suffix",
            }
            | (params_dict.get("drop_obs_details_prefix") or {}),
            method="call",
        ),
        "extract_date": Node(
            async_task=extract_column_as_type.validate()
            .set_task_instance_id("extract_date")
            .handle_errors()
            .with_tracing()
            .set_executor("lithops"),
            partial={
                "df": DependsOn("drop_obs_details_prefix"),
                "column_name": "recorded_at",
                "output_type": "date",
                "output_column_name": "date",
            }
            | (params_dict.get("extract_date") or {}),
            method="call",
        ),
        "filtered_weather_station": Node(
            async_task=filter_row_values.validate()
            .set_task_instance_id("filtered_weather_station")
            .handle_errors()
            .with_tracing()
            .set_executor("lithops"),
            partial={
                "df": DependsOn("extract_date"),
                "column": "weather_station",
            }
            | (params_dict.get("filtered_weather_station") or {}),
            method="call",
        ),
        "groupers": Node(
            async_task=set_groupers.validate()
            .set_task_instance_id("groupers")
            .handle_errors()
            .with_tracing()
            .set_executor("lithops"),
            partial=(params_dict.get("groupers") or {}),
            method="call",
        ),
        "df_with_temporal_index": Node(
            async_task=add_temporal_index.validate()
            .set_task_instance_id("df_with_temporal_index")
            .handle_errors()
            .with_tracing()
            .set_executor("lithops"),
            partial={
                "df": DependsOn("filtered_weather_station"),
                "time_col": "recorded_at",
                "groupers": DependsOn("groupers"),
                "cast_to_datetime": True,
                "format": "mixed",
            }
            | (params_dict.get("df_with_temporal_index") or {}),
            method="call",
        ),
        "split_weather_groups": Node(
            async_task=split_groups.validate()
            .set_task_instance_id("split_weather_groups")
            .handle_errors()
            .with_tracing()
            .set_executor("lithops"),
            partial={
                "df": DependsOn("df_with_temporal_index"),
                "groupers": DependsOn("groupers"),
            }
            | (params_dict.get("split_weather_groups") or {}),
            method="call",
        ),
        "persist_observations": Node(
            async_task=persist_df_wrapper.validate()
            .set_task_instance_id("persist_observations")
            .handle_errors()
            .with_tracing()
            .set_executor("lithops"),
            partial={
                "root_path": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
                "sanitize": True,
            }
            | (params_dict.get("persist_observations") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["df"],
                "argvalues": DependsOn("split_weather_groups"),
            },
        ),
        "daily_weather": Node(
            async_task=summarize_df.validate()
            .set_task_instance_id("daily_weather")
            .handle_errors()
            .with_tracing()
            .set_executor("lithops"),
            partial={
                "groupby_cols": [
                    "weather_station",
                    "date",
                ],
                "summary_params": [
                    {
                        "display_name": "daily_precipitation",
                        "aggregator": "sum",
                        "column": "precipitation",
                    },
                    {
                        "display_name": "daily_temperature",
                        "aggregator": "mean",
                        "column": "surface_air_temperature",
                    },
                ],
                "reset_index": True,
            }
            | (params_dict.get("daily_weather") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["df"],
                "argvalues": DependsOn("split_weather_groups"),
            },
        ),
        "persist_daily_summary": Node(
            async_task=persist_df_wrapper.validate()
            .set_task_instance_id("persist_daily_summary")
            .handle_errors()
            .with_tracing()
            .set_executor("lithops"),
            partial={
                "root_path": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
                "filetypes": [
                    "csv",
                ],
                "sanitize": False,
            }
            | (params_dict.get("persist_daily_summary") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["df"],
                "argvalues": DependsOn("daily_weather"),
            },
        ),
        "precipitation_chart": Node(
            async_task=draw_line_chart.validate()
            .set_task_instance_id("precipitation_chart")
            .handle_errors()
            .with_tracing()
            .set_executor("lithops"),
            partial={
                "x_column": "date",
                "y_column": "daily_precipitation",
                "category_column": "weather_station",
                "line_kwargs": {
                    "shape": "hvh",
                },
                "layout_kwargs": {
                    "xaxis": {
                        "title": "Date",
                    },
                    "yaxis": {
                        "title": "Precipitation (mm)",
                    },
                    "legend_title": "Weather Station",
                    "hovermode": "closest",
                },
            }
            | (params_dict.get("precipitation_chart") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["dataframe"],
                "argvalues": DependsOn("daily_weather"),
            },
        ),
        "persist_precipitation": Node(
            async_task=persist_text.validate()
            .set_task_instance_id("persist_precipitation")
            .handle_errors()
            .with_tracing()
            .set_executor("lithops"),
            partial={
                "root_path": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
            }
            | (params_dict.get("persist_precipitation") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["text"],
                "argvalues": DependsOn("precipitation_chart"),
            },
        ),
        "precipitation_chart_widget": Node(
            async_task=create_plot_widget_single_view.validate()
            .set_task_instance_id("precipitation_chart_widget")
            .handle_errors()
            .with_tracing()
            .set_executor("lithops"),
            partial={
                "title": "Daily Precipitation by Station",
            }
            | (params_dict.get("precipitation_chart_widget") or {}),
            method="map",
            kwargs={
                "argnames": ["view", "data"],
                "argvalues": DependsOn("persist_precipitation"),
            },
        ),
        "grouped_precipitation_widget": Node(
            async_task=merge_widget_views.validate()
            .set_task_instance_id("grouped_precipitation_widget")
            .handle_errors()
            .with_tracing()
            .set_executor("lithops"),
            partial={
                "widgets": DependsOn("precipitation_chart_widget"),
            }
            | (params_dict.get("grouped_precipitation_widget") or {}),
            method="call",
        ),
        "temperature_chart": Node(
            async_task=draw_line_chart.validate()
            .set_task_instance_id("temperature_chart")
            .handle_errors()
            .with_tracing()
            .set_executor("lithops"),
            partial={
                "x_column": "date",
                "y_column": "daily_temperature",
                "category_column": "weather_station",
                "line_kwargs": {
                    "shape": "spline",
                },
                "layout_kwargs": {
                    "xaxis": {
                        "title": "Date",
                    },
                    "yaxis": {
                        "title": "Average Daily Temperature (Celsius)",
                    },
                    "legend_title": "Weather Station",
                    "hovermode": "closest",
                },
            }
            | (params_dict.get("temperature_chart") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["dataframe"],
                "argvalues": DependsOn("daily_weather"),
            },
        ),
        "persist_temperature": Node(
            async_task=persist_text.validate()
            .set_task_instance_id("persist_temperature")
            .handle_errors()
            .with_tracing()
            .set_executor("lithops"),
            partial={
                "root_path": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
            }
            | (params_dict.get("persist_temperature") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["text"],
                "argvalues": DependsOn("temperature_chart"),
            },
        ),
        "temperature_chart_widget": Node(
            async_task=create_plot_widget_single_view.validate()
            .set_task_instance_id("temperature_chart_widget")
            .handle_errors()
            .with_tracing()
            .set_executor("lithops"),
            partial={
                "title": "Daily Temperature by Station",
            }
            | (params_dict.get("temperature_chart_widget") or {}),
            method="map",
            kwargs={
                "argnames": ["view", "data"],
                "argvalues": DependsOn("persist_temperature"),
            },
        ),
        "grouped_temperature_widget": Node(
            async_task=merge_widget_views.validate()
            .set_task_instance_id("grouped_temperature_widget")
            .handle_errors()
            .with_tracing()
            .set_executor("lithops"),
            partial={
                "widgets": DependsOn("temperature_chart_widget"),
            }
            | (params_dict.get("grouped_temperature_widget") or {}),
            method="call",
        ),
        "weather_dashboard": Node(
            async_task=gather_dashboard.validate()
            .set_task_instance_id("weather_dashboard")
            .handle_errors()
            .with_tracing()
            .set_executor("lithops"),
            partial={
                "details": DependsOn("workflow_details"),
                "widgets": [
                    DependsOn("grouped_precipitation_widget"),
                    DependsOn("grouped_temperature_widget"),
                ],
                "time_range": DependsOn("time_range"),
                "groupers": DependsOn("groupers"),
            }
            | (params_dict.get("weather_dashboard") or {}),
            method="call",
        ),
    }
    graph = Graph(dependencies=dependencies, nodes=nodes)
    results = graph.execute()
    return results
